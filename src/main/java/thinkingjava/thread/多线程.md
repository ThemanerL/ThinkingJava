1. 进程是一个静态的概念，线程是一个进程中不同的执行路径。使用Run方法是方法的调用而不是线程的启动，必须调用Thread.start()来启动新的线程。

|方法|功能|
|:--|:--|
|isAlive()|判断线程是否还“活着”，即线程是否还未终止（阻塞，运行，就绪都没dead）|
|getPriority()|获得线程的优先级数值|
|setPriority()|设置线程的优先级数值（优先级越高，获得的CPU时间越多）|
|Thread.sleep()|将当前线程睡眠指定毫秒数|
|join()|调用某线程的该方法，将该线程与当前线程进行“合并”，即等待该线程结束，再恢复当前线程的运行|
|yield()|让出CPU，当前线程进入就绪队列等待调度|
|wait()|当前线程进入对象的waitPool|
|notify()|唤醒对象的waitPool中的一个等待线程|
|notifyAll()|唤醒对象的waitPool中所有的等待线程|  

死锁产生的四个条件:  
 - 互斥:某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
 - 占有且等待:一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
 - 不可抢占:别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
 - 循环等待:存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。
将Synchronized加到非静态的方法和代码块中，即在执行该方法时，锁定当前对象。
将Synchronized加到静态的成员或者类名上，锁定的是该类的class对象，即该类的所有对象同一把锁。

