### JDK1.8
- [ ] 对内存结构的优化
- [x] Lambda表达式
- [x] 函数式编程
- [ ] Stream
- [ ] 新日期和时间
- [x] 方法与构造函数引用
#### HashMap
1. 负载因子：默认为0.75即：当已存储元素达到最终容量的75%进行扩容；重新运算HashCode相同的元素，加载数组的后面。
1. hash算法：我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。  
所以我们首先想到的就是把HashCode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，
    ```java
        static int indexFor(int h, int length) {  
            return h & (length-1);
        }
    ```
    首先算得key得HashCode值，然后跟数组的长度-1做一次“与”运算（&）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么HashCode就会和2的4次方-1做“与”运算。这个方法非常巧妙，它通过```h & (table.length -1)```来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。我以2的4次方举例，来解释一下为什么数组大小为2的幂时HashMap访问的性能最高。  
     ![](https://thinkingjava-md-1257967443.cos.ap-guangzhou.myqcloud.com/HashMapIndex.jpg)
     如上图所示。左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101**这几个位置永远都不能存放元素**了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 
1. HashMap的resize  
    当HashMap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。  
    那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，即使是1000，HashMap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751024 = 768 < 1000,虽然HashMap的容量是1024，且我们只存储1000个元素，但是当存储第769个元素的时候，HashMap会自动扩容,也就是说为了让0.75size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。 
1. JDK1.8的优化  
    数组-->链表-->红黑树;如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。且HashMap的总大小大于64的时候
#### ConcurrentHashMap
1. 从JDK1.7的锁分段机制更改为CAS算法;无锁算法
#### Java内存结构
1. 栈、堆、方法区(在堆的永久区部分)、永久区;JDK1.8之后， 将永久区和方法区进行合并为MetaSpace元空间，使用物理内存 
#### Lambda表达式
如lambda的有只有一个参数，则小括号可以省略不写  
若Lambda体只有一条一句，则大括号和return都可以省略  
**注意**:匿名内部类内部引用同级别的局部变量，只能调用final修饰的变量
#### 方法引用   
若Lambda体中的内容有方法已经实现了，我们可以使用“方法引用”，可以理解为方法引用是Lambda表达式的另外一种表现形式。主要有三种语法格式:
1. 对象::实例方法名
2. 类名::静态方法名
3. 类名::实例方法名
注意:Lambda的接口参数和返回值类型要与当前调用的方法的参数和返回值的类型相同