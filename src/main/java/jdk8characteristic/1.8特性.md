### JDK1.8
- [ ] 对内存结构的优化
- [x] Lambda表达式
- [x] 函数式编程
- [x] Stream
- [ ] 新日期和时间
- [x] 方法与构造函数引用
### HashMap
1. 负载因子：默认为0.75即：当已存储元素达到最终容量的75%进行扩容；重新运算HashCode相同的元素，加载数组的后面。
1. hash算法：我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。  
所以我们首先想到的就是把HashCode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的，
    ```java
        static int indexFor(int h, int length) {  
            return h & (length-1);
        }
    ```
    首先算得key得HashCode值，然后跟数组的长度-1做一次“与”运算（&）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么HashCode就会和2的4次方-1做“与”运算。这个方法非常巧妙，它通过```h & (table.length -1)```来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。我以2的4次方举例，来解释一下为什么数组大小为2的幂时HashMap访问的性能最高。  
     ![](https://thinkingjava-md-1257967443.cos.ap-guangzhou.myqcloud.com/hashmapIndex.jpg)  
     如上图所示。左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101**这几个位置永远都不能存放元素**了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 
1. HashMap的resize  
    当HashMap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。  
    那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，即使是1000，HashMap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751024 = 768 < 1000,虽然HashMap的容量是1024，且我们只存储1000个元素，但是当存储第769个元素的时候，HashMap会自动扩容,也就是说为了让0.75size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。 
1. JDK1.8的优化  
    数组-->链表-->红黑树;如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。且HashMap的总大小大于64的时候
### ConcurrentHashMap
1. 从JDK1.7的锁分段机制更改为CAS算法;无锁算法
### Java内存结构
1. 栈、堆、方法区(在堆的永久区部分)、永久区;JDK1.8之后， 将永久区和方法区进行合并为MetaSpace元空间，使用物理内存 
### Lambda表达式
如lambda的有只有一个参数，则小括号可以省略不写  
若Lambda体只有一条一句，则大括号和return都可以省略  
**注意**:匿名内部类内部引用同级别的局部变量，只能调用final修饰的变量
### 方法引用   
若Lambda体中的内容有方法已经实现了，我们可以使用“方法引用”，可以理解为方法引用是Lambda表达式的另外一种表现形式。主要有三种语法格式:
1. 对象::实例方法名
2. 类名::静态方法名
3. 类名::实例方法名
注意:Lambda的接口参数和返回值类型要与当前调用的方法的参数和返回值的类型相同
### Stream  
Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。**集合讲的是数据，流讲的是运算。**  
![Stream流程](https://thinkingjava-md-1257967443.cos.ap-guangzhou.myqcloud.com/jdk1.8stream.png)  
1. 创建Stream:一个数据源(如:集合、数组)，获取一个流。  
1. 中间操作:一个中间操作链，对数据源的数据进行处理。  
    1. 筛选和切片
        - filter:接收Lambda，从流中排除某些元素
        - limit:截断流，使其元素不超过给定的数量
        - skip(n):跳过元素，返回一个扔掉了前n个元素的流，若流中元素的数量不足n个，则返回一个空流。与limit(n)互补
        - distinct:筛选，通过流所生成的hashCode()和equals()去除重复元素
    1. 映射
        - map:接收Lambda表达式，将元素转换为其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素
        - flatMap:接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流
    1. 排序 
1. 终止操作:一个终止操作，执行中间操作链，并产生结果。
    1. 查找与匹配
        - allMatch:检查是否匹配所有元素
        - anyMatch:检查是否至少一个匹配元素
        - noneMatch:检查是否没有匹配所有元素  
        - findFirst:返回第一个元素
        - findAny:返回当前流中的任意元素
        - count:返回流中元素的总个数
        - max:返回流中的最大值
        - main:返回流中的最小值
    1. 归约
        - reduce:将流中的元素返回结合起来，得到一个值
    1. 收集
        - collect:将流转换为其他形式。接收一个Collection接口的实现，用于给Stream中元素做汇总。  
        Collector接口中方法的实现决定了如何对流执行收集操作(如，收集到List、Set、Map)。但是Collector实用类提供了很多静态方法，可以方便的创建常用收集器实例。
1. Optional:避免NPE，Optional.orElse(T other), 如果Optional容器为空，则就可以有一个替代的对象other;类似于Sql语句中的ifNull(expr1,expr2)
1. 并行流与串行流  
    - 并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。
    - Stream API可以声明式地通过parallel()与sequential()在并行流与顺序流之间进行切换。
注意:  
1. Stream 自己不会存储元素。
2. Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream
3. Stream 操作是延迟进行的。意思是Stream会等到需要结果的时候才执行。
### Optional类  
1. Optional<T>类是一个容器类，代表一个值存在或不存在，原来用null表示一个值不存在，现在用optional表达这个概念，避免NPE。常用方法:
    - Optional.of(T t):创建一个Optional实例
    - Optional.empty():创建一个空的Optional实例
    - Optional.ofNullable(T t):若t不为null，创建Optional实例，否则创建空实例
    - isPresent():判断是否包含值
    - orElse(T t):如果调用对象包含值，返回该值，否则返回t
    - orElseGet(Supplier s):如果对象包含值，返回该值，否则返回s获取的值
    - map(Function f):如果有值对齐进行处理，并返回处理后的Optional，否则返回Optional.empty()
    - flatMap(Function mapper):与Map类似，要求返回值必须是Optional

